{
  "api/ui/index.html": {
    "href": "api/ui/index.html",
    "title": "Overview | SkiaSharp.Extended",
    "keywords": "Overview SkiaSharp.Extended.Controls is a collection some great Xamarin.Forms controls that may be useful to some apps. SKImageSourceExtensions Some useful extensions for the abstract ImageSource type. See more... SKConfettiView The confetti view is a container for one or more systems of confetti particles. See more... Preivew"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "Overview | SkiaSharp.Extended",
    "keywords": "Overview SkiaSharp.Extended SkiaSharp.Extended is a collection some cool libraries that may be useful to some apps. There are several repositories that may have interesting projects. See more... SKBlurHash SKBlurHash is a compact representation of a placeholder for an image. See more... SKGeometry SKGeometry provides several helper methods that can be used to create common geometric shapes. See more... SKPathInterpolation SKPathInterpolation can be used to create interpolated paths. This is awesome when creating animated shapes or transitions between two paths. See more... SkiaSharp.Extended.UI See more... SKImageSourceExtensions Some useful extensions for the abstract ImageSource type. See more... SKConfettiView The confetti view is a container for one or more systems of confetti particles. See more... Deprecated / Unmaintained Libraries IMPORTANT Some parts of these libraries are deprecated. SkiaSharp.Extended.Iconify See more... SkiaSharp.Extended.Svg See more..."
  },
  "api/extended/skpathinterpolation.html": {
    "href": "api/extended/skpathinterpolation.html",
    "title": "SKPathInterpolation | SkiaSharp.Extended",
    "keywords": "SKPathInterpolation SKPathInterpolation can be used to create interpolated paths. This is awesome when creating animated shapes or transitions between two paths. Path Interpolation The code is also very simple, just create a SKPathInterpolation instance and then ask for each step: var interpolation = new SKPathInterpolation(startPath, endPath); var halfWayPath = interpolation.Interpolate(0.5f); var almostTherePath = interpolation.Interpolate(0.9f); Methods There are a few helper methods that can be used to create geometric shapes in the SKGeometry type: Method Description Interpolate Creates a new path interpolated between the start and end paths."
  },
  "api/extended/index.html": {
    "href": "api/extended/index.html",
    "title": "Overview | SkiaSharp.Extended",
    "keywords": "Overview SkiaSharp.Extended is a collection some cool functions that may be useful to some apps. SKBlurHash SKBlurHash is a compact representation of a placeholder for an image. See more... Preview SKGeometry SKGeometry provides several helper methods that can be used to create common geometric shapes. See more... SKPathInterpolation SKPathInterpolation can be used to create interpolated paths. This is awesome when creating animated shapes or transitions between two paths. See more... Preview"
  },
  "api/ui/skimagesourceextensions.html": {
    "href": "api/ui/skimagesourceextensions.html",
    "title": "SKImageSourceExtensions | SkiaSharp.Extended",
    "keywords": "SKImageSourceExtensions Some useful extensions for the abstract ImageSource type for when working with Xamarin.Forms images and SkiaSharp paintings. Methods The main property of a confetti view is the Systems property: Methods Description ToSKImageAsync Convert any ImageSource into an SKImage instance."
  },
  "api/ui/skconfettiview.html": {
    "href": "api/ui/skconfettiview.html",
    "title": "SKConfettiView | SkiaSharp.Extended",
    "keywords": "SKConfettiView The confetti view is a container for one or more systems of particles. Top + Stream Center + Burst Sides + Multiple Properties The main property of a confetti view is the Systems property: Property Type Description Systems SKConfettiSystemCollection The collection of systems in the view. IsRunning bool Controls whether the all systems are running or not. IsComplete bool A value that indicates whether all systems are complete. Parts In addition to the properties on the view and all the systems, there is the overall control template that can directly influence the visual appearance of the view. The default template is defined as: <ControlTemplate x:Key=\"SKConfettiViewControlTemplate\"> <skia:SKCanvasView x:Name=\"PART_DrawingSurface\" /> </ControlTemplate> Part Description PART_DrawingSurface This part can either be a SKCanvasView or a SKGLView and describes the actual rendering surface for the confetti. System Every confetti view consists up one or more systems ( SKConfettiSystem ). Each system is a container for an emitter ( SKConfettiEmitter ) along with many properties on how the system runs. Property Type Description Emitter SKConfettiEmitter An emitter controls how the confetti particles are generated and at what rate for how long. EmitterBounds SKConfettiEmitterBounds The emitter bounds controls where in the view the particles appear. This can be from a side (left, right, top, bottom), a point or a rectangular region. Gravity Point The gravity is a acceleration vector that indicates the direction and strength of the gravity in the system. Colors SKConfettiColorCollection A collection of Color instances that determine the available colors for the confetti. Physics SKConfettiPhysicsCollection A collection of SKConfettiPhysics instances that determine the \"base\" mass and size of each confetti particle. Shapes SKConfettiShapeCollection A collection of SKConfettiShape instances that determine what each confetti particle looks like. StartAngle double The angle (in degrees) to form the start of the emission region. EndAngle double The angle (in degrees) to form the end of the emission region. MinimumInitialVelocity double The minimum initial velocity of the confetti particles. MaximumInitialVelocity double The maximum initial velocity of the confetti particles. MinimumRotationVelocity double The minimum initial rotation velocity of the confetti particles. MaximumRotationVelocity double The maximum initial rotation velocity of the confetti particles. MaximumVelocity double The maximum velocity the confetti particle can reach. FadeOut bool Whether or not the particle should fade out at the end of its life. Lifetime double The duration in seconds for how long the particle is allowed to live. IsRunning bool Controls whether the system is running or not. IsComplete bool A value that indicates whether the system is complete and all systems and particles are also complete. Emitter Each system has an emitter instance that controls how the confetti particles are generated and at what rate for how long. Property Type Description ParticleRate int The number of particles to generate each second. MaxParticles int The maximum number of particles allowed by the emitter. A value of -1 indicates no limit. Duration double The duration in seconds of how long the emitter runs for. A value of 0 indicates that all particles are emitted instantly. IsComplete bool A value that indicates whether the emitter has generated all the particles and they have all disappeared. Helper Emitters To make creating emitters easier, there are a few static helper methods on the SKConfettiEmitter type: Property Description Burst Create an emitter that generates the specified number of the particles instantly. Infinite Create an emitter that releases the specified number of particles each second. Stream Create an emitter that releases the specified number of particles for the specified amount of time. Shapes There are several simple types of \"shapes\" that the confetti can come in: Name Type Description Circle SKConfettiCircleShape This is a simple circle shape. Square SKConfettiSquareShape This is a simple square with equal length sides. Oval SKConfettiOvalShape This is the stretched circle or ellipse shape. This has a useful property HeightRatio that can be used to control the width/height ratio in the range of [0..1]. Rectangle SKConfettiRectShape This is a rectangle. This has a useful property HeightRatio that can be used to control the width/height ratio in the range of [0..1]. Advanced Shapes In addition to those, there is also a way to have custom paths as a shape: Name Type Description Paths SKConfettiPathShape This is a generic shape that supports any SKPath instance Custom SKConfettiShape This is the base type for shapes. Custom drawing code can be used by deriving from this type and overriding the OnDraw method. When making a custom shape, the instance is re-used, so all state needs to be set before drawing. The provided SKPaint instance is reset, so any properties set needs to be re-set. Custom Shapes public class ConfettiStar : SKConfettiShape { private readonly int points; public ConfettiStar(int points) { this.points = points; } protected override void OnDraw(SKCanvas canvas, SKPaint paint, float size) { using var star = SKGeometry.CreateRegularStarPath(size, size / 2, points); canvas.DrawPath(star, paint); } } Physics Each particle can have a size and mass, and the emitter can select one of them randomly: Property Type Description Mass double The mass of the particle which resists the force of gravity. Size double The physical size of the particle rendered."
  },
  "index.html": {
    "href": "index.html",
    "title": "SkiaSharp.Extended | SkiaSharp.Extended",
    "keywords": "SkiaSharp.Extended SkiaSharp.Extended is a collection some cool libraries that may be useful to some apps. There are several repositories that may have interesting projects: SkiaSharp.Extended (additional APIs) SKBlurHash SKBlurHash is a compact representation of a placeholder for an image. SKGeometry SKGeometry provides several helper methods that can be used to create common geometric shapes. SKPathInterpolation SKPathInterpolation can be used to create interpolated paths. This is awesome when creating animated shapes or transitions between two paths. SkiaSharp.Extended.UI (additional Xamarin.Forms UI components & controls) SKImageSourceExtensions Some useful extensions for the abstract ImageSource type. SKConfettiView The confetti view is a container for one or more systems of particles. Deprecated / Unmaintained Libraries SkiaSharp.Extended.Iconify (iconify library) Use https://github.com/toptensoftware/RichTextKit instead. SkiaSharp.Extended.Svg (lightweight SVG loader) Use https://github.com/wieslawsoltes/Svg.Skia instead."
  },
  "api/extended/skgeometry.html": {
    "href": "api/extended/skgeometry.html",
    "title": "SKGeometry | SkiaSharp.Extended",
    "keywords": "SKGeometry SKGeometry provides several helper methods that can be used to create common geometric shapes. Methods There are a few helper methods that can be used to create geometric shapes in the SKGeometry type: Method Description CreateSectorPath Creates a path with the shape of sector/section of a doughnut/pie chart. CreatePiePath Creates a path with the shape of a doughnut/pie chart. CreateSquarePath Creates a path with the shape of a square. CreateRectanglePath Creates a path with the shape of a rectangle. CreateTrianglePath Creates a path with the shape of a triangle. CreateRegularPolygonPath Creates a path with the shape of some regular polygon. CreateRegularStarPath Creates a path with the shape of a square. Extension Methods Some of these shapes can also be draw directly on a SKCanvas using the extensions methods: SKCanvas canvas = ... canvas.DrawStar( 100, 100, // x, y 100, // outer radius 50, // inner radius 5); // points"
  },
  "api/extended/skblurhash.html": {
    "href": "api/extended/skblurhash.html",
    "title": "SKBlurHash | SkiaSharp.Extended",
    "keywords": "SKBlurHash A BlurHash is a compact representation of a placeholder for an image. For example, the SkiaSharp logo can be reduced to a tiny string: LjPsbRxG%gx^aJxuM|W=?^X8Mxn$ Original (79.7 KB) BlurHash (36 bytes) Methods TODO"
  },
  "api/svg/svg.html": {
    "href": "api/svg/svg.html",
    "title": "SkiaSharp.Extended.Svg | SkiaSharp.Extended",
    "keywords": "SkiaSharp.Extended.Svg IMPORTANT This library is deprecated. Use https://github.com/wieslawsoltes/Svg.Skia instead. SkiaSharp.Svg is lightweight SVG parser that can be used for most SVG needs. Support for SVG has been a hot topic, but Google has stated that this is not going to be a feature coming soon. However, we do want to support SVG. To this end, we are trying out a lightweight SVG parser. This is a pure managed code parser, that actually lives in a single file. This implementation of SVG is fairly limited, but supports all the features supported by the alternate NGraphics library (and a bit more). We are looking to add new features, so please do create issues when you need a feature that does not exist yet. // create a new SVG object var svg = new SKSvg(); // load the SVG document svg.Load(\"image.svg\"); // draw the svg SKCanvas canvas = ... canvas.DrawPicture(svg.Picture); This will draw the SVG at the size that it was created. To control the size, you can make use of a scale SKMatrix : // get the rectangle that the SVG is defined in var svgSize = svg.Picture.CullRect; float svgMax = Math.Max(svgSize.Width, svgSize.Height); // calculate the scaling need to fit float canvasMin = Math.Min(width, height); float scale = canvasMin / svgMax; var matrix = SKMatrix.MakeScale(scale, scale); // draw the svg canvas.DrawPicture(svg.Picture, ref matrix);"
  },
  "api/svg/index.html": {
    "href": "api/svg/index.html",
    "title": "Overview | SkiaSharp.Extended",
    "keywords": "Overview IMPORTANT This library is deprecated. Use https://github.com/wieslawsoltes/Svg.Skia instead. SkiaSharp.Extended.Svg See more..."
  },
  "api/iconify/index.html": {
    "href": "api/iconify/index.html",
    "title": "Overview | SkiaSharp.Extended",
    "keywords": "Overview IMPORTANT This set of libraries are deprecated. Use https://github.com/toptensoftware/RichTextKit instead. SkiaSharp.Extended.Iconify See more..."
  },
  "api/iconify/iconify.html": {
    "href": "api/iconify/iconify.html",
    "title": "SkiaSharp.Extended.Iconify | SkiaSharp.Extended",
    "keywords": "SkiaSharp.Extended.Iconify IMPORTANT This set of libraries are deprecated. Use https://github.com/toptensoftware/RichTextKit instead. A simple way to draw a string that contains icons inline with normal characters. For example, if we wanted to draw this string using colored characters from FontAwesome (or some other icon font) mixed in with other characters: Preview To do this using factory SkiaSharp, there would be lots of work that needed doing. But, not anymore. First, we can use nice templated strings: var text = \"I {{fa-heart-o color=ff0000}} to {{fa-code}} on {{fa-windows color=1BA1E2}}!\"; There are a few things that make this work: The {{...}} double curly braces tell the engine that this is a special character. The first part of the block is CSS class name of the FontAwesome icon. In the case of the red heart outline, this is the fa-heart-o . The second part is optional, and can be specified to control the color color=ff0000 . In this case, we are specifying red using the hex color code, #FF0000 . More optional flags may be added later, but right now there is just the color flag. This flag can be any value that can be passed to the SKColor.Parse method. To draw this text, all we have to do is register the icon font in app startup, or whenever we need: SKTextRunLookup.Instance.AddFontAwesome(); Now, we can draw the string anywhere in the app: // create the paint that represents the default text var paint = new SKPaint(); // draw the text, inserting all the FontAwesome characters canvas.DrawIconifiedText(text, 10, 100, paint); Supported Icon Fonts There are several icon fonts that are currently supported: FontAwesome - http://fontawesome.io/ IonIcons - http://ionicons.com/ Material Design Icons (community) - https://materialdesignicons.com/ Material Icons (Google) - https://material.io/icons/ Meteocons - http://www.alessioatzeni.com/meteocons/ Simple Line Icons - http://simplelineicons.com/ Typicons - http://www.typicons.com/ WeatherIcons - http://weathericons.io/ These are just what we have now, but it is very simple to add some more. All we need is the .ttf font file and some mapping from a name to the unicode character. Advanced If we want to control what fonts are available for a specific draw operation, we can create a lookup table: // create the lookup table var lookup = new SKTextRunLookup(); // add FontAwesome lookup.AddTypeface(new FontAwesomeLookupEntry()); Now that we have our table, we can draw the string: // create the paint that represents the default text var paint = new SKPaint(); // draw the text, inserting all the FontAwesome characters canvas.DrawIconifiedText(text, 10, 100, lookup, paint); For more advanced text substitutions, there is a way to directly control the creation of these strings. Instead of just passing a string to DrawIconifiedText , we can \"cache\" or pre-calculate this string using SKTextRun : // create the text runs IEnumerable<SKTextRun> runs = SKTextRun.Create(text, lookup); // draw the text canvas.DrawText(runs, 10, 100, paint); Another way to work with this is to directly create the text runs: var runs = new [] { new SKTextRun(\"I \"), new SKTextRun(\"\\uf08a\") { Color = SKColors.Red, Typeface = SKTypeface.FromFamilyName(\"FontAwesome\"), TextSize = 50 }, new SKTextRun(\" to \"), // ... };"
  }
}